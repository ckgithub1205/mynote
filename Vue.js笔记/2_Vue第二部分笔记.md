# 1.组件化思想
## 1.什么是组件化
![](_v_images/20200530175210008_27761.png)
## 2.Vue组件化思想
![](_v_images/20200530175832491_13768.png)
## 3.注册组件的基本步骤
![](_v_images/20200530180131709_11649.png)
使用组件的三个步骤：
1.使用Vue.extend()方法创建组件构造器
2.使用Vue.component()方法注册组件
3.在Vue实例的作用范围内使用组件
![](_v_images/20200530210231266_12491.png)
## 4.全局组件和局部组件
1.通过extend()方法和component()方法注册的是全局组件！
2.在Vue实例中，通过compontens属性注册的组件，是局部组件，作用域只在该实例范围内
***在开发中用的最多的是局部组件!***

![](_v_images/20200530211208019_30330.png)
## 5.父组件和子组件
![](_v_images/20200530212039176_18940.png)
## 6.注册组件的语法糖
### 1.全局组件的注册语法糖
![](_v_images/20200530214018938_26680.png)
### 2.局部注册的语法糖

![](_v_images/20200530214644671_28651.png)
与全局注册语法糖类似，只是放在了属性compontents中
![](_v_images/20200530214859175_27536.png)
## 7.组件模板的抽离
### 1.第1种方式,通过script标签

![](_v_images/20200530220320309_21140.png)
### 2.第2种方式,通过template标签
![](_v_images/20200530220552545_6430.png)
![](_v_images/20200530220642074_30320.png)
## 8.为什么组件的data必须是函数？
![](_v_images/20200530221245706_8345.png)
## 9.父子组件间的通信
![](_v_images/20200531092932471_2928.png)
### 1.父组件向子组件传值
![](_v_images/20200531093942443_2648.png)
![](_v_images/20200531094047569_2552.png)
#### 1.通过props数组的方式进行传值
![](_v_images/20200531102136361_15707.png)
#### 2.通过props对象的方式进行传值
这种方式可以自定义传值的类型，默认值以及数据验证
![](_v_images/20200531104419468_25435.png)
这是另外两种父传值的写法！
#### 3.props驼峰标识符注意点
驼峰命名法的转换
如果是cInfo,  那么标签中就需要这样写：    c-info

### 2.子组件向父组件传值
![](_v_images/20200531111019589_17901.png)

![](_v_images/20200531111055153_26182.png)
父子间组件通讯的总结：
1.父组件向子组件传递数据：
通过props属性
2.子组件向父组件传递数据：
通过自定义事件，  $emit方法来监听
![](_v_images/20200531113315960_30329.png)

### 3.父子组件的访问方式
![](_v_images/20200531172313844_3019.png)
父组件访问子组件：使用$children或者$refs
子组件访问父组件：使用$parent

![](_v_images/20200531174947262_14107.png)

子组件访问父组件的方式   this.$parent.属性    |     this.$parent.方法
子组件访问root组件的方式   this.$root.属性    |      this.$root.方法

# 2.插槽的使用 slot
## 1.为什么要使用插槽
![](_v_images/20200531183149951_6930.png)
## 2.如何封装这类组件呢？

![](_v_images/20200531183532253_11255.png)
插槽的几个知识点：
1.插槽的基本使用：   <slot></slot>
1.插槽的默认值
2.如果有多个元素，会全部替换掉插槽位置
## 3.插槽的基本使用
![](_v_images/20200531184346379_18652.png)
## 4.具名插槽的使用
![](_v_images/20200531190009019_22690.png)
## 5.编译作用域的概念
组件总是在自己的实例范围内找到对应的属性或方法
![](_v_images/20200531191218855_13919.png)

## 6.作用域插槽

![](_v_images/20200531191948696_29864.png)
![](_v_images/20200531193043979_30524.png) 


# 3.模块化开发
## 1.不使用模块化会出现的问题？
![](_v_images/20200531200427779_11106.png)
## 2.使用ES5语法自己封装原生的模块
![](_v_images/20200531201339836_16058.png)

![](_v_images/20200531201655288_4629.png)

常见的模块化规范:
* CommonJS
* AMD
* CMD
* 还有ES6的Modules

## 3.CommonJS了解
![](_v_images/20200531211522531_7926.png)
## 4.export基本使用
![](_v_images/20200531213348981_20530.png)
![](_v_images/20200531213319700_20059.png)
![](_v_images/20200531213448350_307.png)
## 5.export default使用
![](_v_images/20200531214115657_4556.png)
## 6.import使用
![](_v_images/20200531214426437_5834.png)